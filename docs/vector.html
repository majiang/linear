<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>linear.vector</title>
        </head><body>
        <h1>linear.vector</h1>
        <!-- Generated by Ddoc from source\linear\vector.d -->
<br><br>
<dl><dt><big><a name="RowVector"></a>struct <u>RowVector</u>(T) if (is(T == Unqual!T));
<br><a name="row"></a>auto <u>row</u>(T)(in T[] <i>payload</i>);
<br>auto <u>row</u>(T)(T[] <i>payload</i>) if (is(T == Unqual!T));
</big></dt>
<dd>Row vector.<br><br>

<dl><dt><big><a name="RowVector.this"></a>this(in size_t <i>length</i>);
</big></dt>
<dd>Zero vector with given <i>length</i>.<br><br>

</dd>
<dt><big><a name="RowVector.this.2"></a>this(T[] <i>payload</i>);
<br>const this(in T[] <i>payload</i>);
</big></dt>
<dd>Initialize RowVector with <i>payload</i>.<br><br>

</dd>
<dt><big><a name="RowVector.opIndexOpAssign"></a>auto <u>opIndexOpAssign</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "*");
<br><a name="RowVector.opBinary"></a>const auto <u>opBinary</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "*");
</big></dt>
<dd>Componentwise product.<br><br>

</dd>
<dt><big><a name="RowVector.opOpAssign"></a>auto <u>opOpAssign</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "+" || op == "-");
<br><a name="RowVector.opBinary.2"></a>const auto <u>opBinary</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "+" || op == "-");
</big></dt>
<dd>Vector addition and subtraction.<br><br>

</dd>
<dt><big><a name="RowVector.opOpAssign.2"></a>auto <u>opOpAssign</u>(string op)(in T <i>rhs</i>) if (op == "*" || op == "/");
<br><a name="RowVector.opBinary.3"></a>const auto <u>opBinary</u>(string op)(in T <i>rhs</i>) if (op == "*" || op == "/");
<br><a name="RowVector.opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op)(in T <i>lhs</i>) if (op == "*");
</big></dt>
<dd>Scalar multiplication and division.<br><br>

</dd>
<dt><big><a name="RowVector.opBinary.4"></a>const auto <u>opBinary</u>(string op)(in ColumnVector!T <i>rhs</i>) if (op == "*");
<br>const auto <u>opBinary</u>(string op)(in T[] <i>rhs</i>) if (op == "*");
</big></dt>
<dd>inner product.<br><br>

</dd>
<dt><big><a name="RowVector.length"></a>const auto <u>length</u>();
</big></dt>
<dd>Length.<br><br>

</dd>
<dt><big><a name="RowVector.opIndex"></a>const auto <u>opIndex</u>();
<br>auto <u>opIndex</u>();
</big></dt>
<dd>For special element-wise operation.<br><br>

</dd>
<dt><big><a name="RowVector.copy"></a>const auto <u>copy</u>();
</big></dt>
<dd>Deep <u>copy</u>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ColumnVector"></a>struct <u>ColumnVector</u>(T) if (is(T == Unqual!T));
<br><a name="column"></a>auto <u>column</u>(T)(in T[] <i>payload</i>);
<br>auto <u>column</u>(T)(T[] <i>payload</i>) if (is(T == Unqual!T));
</big></dt>
<dd>Column vector.<br><br>

<dl><dt><big><a name="ColumnVector.this"></a>this(in size_t <i>length</i>);
</big></dt>
<dd>Zero vector with given <i>length</i>.<br><br>

</dd>
<dt><big><a name="ColumnVector.this.2"></a>this(T[] <i>payload</i>);
</big></dt>
<dd>Initialize ColumnVector with <i>payload</i>.<br><br>

</dd>
<dt><big><a name="ColumnVector.this.3"></a>const this(in T[] <i>payload</i>);
</big></dt>
<dd>Initialize ColumnVector with <i>payload</i>.<br><br>

</dd>
<dt><big><a name="ColumnVector.opIndexOpAssign"></a>auto <u>opIndexOpAssign</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "*");
<br><a name="ColumnVector.opBinary"></a>const auto <u>opBinary</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "*");
</big></dt>
<dd>Componentwise product.<br><br>

</dd>
<dt><big><a name="ColumnVector.opOpAssign"></a>auto <u>opOpAssign</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "+" || op == "-");
<br><a name="ColumnVector.opBinary.2"></a>const auto <u>opBinary</u>(string op)(in typeof(this) <i>rhs</i>) if (op == "+" || op == "-");
</big></dt>
<dd>Vector addition and subtraction.<br><br>

</dd>
<dt><big><a name="ColumnVector.opOpAssign.2"></a>auto <u>opOpAssign</u>(string op)(in T <i>rhs</i>) if (op == "*" || op == "/");
<br><a name="ColumnVector.opBinary.3"></a>const auto <u>opBinary</u>(string op)(in T <i>rhs</i>) if (op == "*" || op == "/");
<br><a name="ColumnVector.opBinaryRight"></a>const auto <u>opBinaryRight</u>(string op)(in T <i>lhs</i>) if (op == "*");
</big></dt>
<dd>Scalar multiplication and division.<br><br>

</dd>
<dt><big><a name="ColumnVector.opBinaryRight.2"></a>const auto <u>opBinaryRight</u>(string op)(in T[] <i>lhs</i>) if (op == "*");
</big></dt>
<dd>inner product.<br><br>

</dd>
<dt><big><a name="ColumnVector.length"></a>const auto <u>length</u>();
</big></dt>
<dd>Length.<br><br>

</dd>
<dt><big><a name="ColumnVector.opIndex"></a>const auto <u>opIndex</u>();
<br>auto <u>opIndex</u>();
</big></dt>
<dd>For special element-wise operation.<br><br>

</dd>
<dt><big><a name="ColumnVector.copy"></a>const auto <u>copy</u>();
</big></dt>
<dd>Deep <u>copy</u>.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ones"></a>auto <u>ones</u>(T)(size_t <i>length</i>);
</big></dt>
<dd>fill by 1s.<br><br>

</dd>
<dt><big><a name="transpose"></a>auto <u>transpose</u>(T)(in RowVector!T <i>row</i>);
<br>auto <u>transpose</u>(T)(RowVector!T <i>row</i>);
<br>auto <u>transpose</u>(T)(in ColumnVector!T <i>column</i>);
<br>auto <u>transpose</u>(T)(ColumnVector!T <i>column</i>);
</big></dt>
<dd>transposition of vector.<br><br>

</dd>
<dt><big><a name="product"></a>auto <u>product</u>(T)(T[] <i>x</i>, T[] <i>y</i>);
</big></dt>
<dd>inner <u>product</u><br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
